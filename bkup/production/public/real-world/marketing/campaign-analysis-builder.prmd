---
id: campaign-analysis-builder
name: Marketing Campaign Analysis & Optimization
version: 1.0.0
description: Comprehensive marketing campaign analysis with attribution, ROI optimization, and audience insights
tags: [marketing, analytics, attribution, roi, optimization]
parameters:
  - name: campaign_type
    type: string
    enum: [digital-ads, email, social-media, content, seo, mixed-channel]
    required: true
    description: Primary campaign type to analyze
  - name: business_model
    type: string
    enum: [b2b-saas, b2c-ecommerce, lead-generation, brand-awareness]
    required: true
    description: Business model and campaign objective
  - name: attribution_model
    type: string
    enum: [first-touch, last-touch, multi-touch, data-driven]
    default: multi-touch
    description: Attribution model for conversion tracking
  - name: time_period
    type: string
    enum: [weekly, monthly, quarterly, annual]
    default: monthly
    description: Analysis time period
  - name: budget_range
    type: string
    enum: [small, medium, large, enterprise]
    required: true
    description: Campaign budget range
  - name: includes_cohort_analysis
    type: boolean
    default: true
    description: Include customer cohort and lifetime value analysis
  - name: competitive_analysis
    type: boolean
    default: false
    description: Include competitive intelligence analysis
---

# Marketing Campaign Analysis: {{campaign_type}} for {{business_model}}

## Analysis Framework

**Campaign Type:** {{campaign_type}}  
**Business Model:** {{business_model}}  
**Attribution Model:** {{attribution_model}}  
**Analysis Period:** {{time_period}}  
**Budget Range:** {{budget_range}}  
**Cohort Analysis:** {{#if includes_cohort_analysis}}Included{{else}}Basic metrics only{{/if}}

---

## 1. Campaign Performance Dashboard (Excel/Google Sheets)

### Executive Summary Dashboard
```excel
=== CAMPAIGN PERFORMANCE DASHBOARD ===

Key Performance Indicators:
Total Campaign Spend:          =SUM(Spend_Data!B:B)
Total Revenue:                 =SUM(Revenue_Data!B:B)  
Return on Ad Spend (ROAS):     =B4/B3
Cost Per Acquisition (CPA):    =B3/SUM(Conversions_Data!B:B)
Customer Lifetime Value (CLV): =Cohort_Analysis!B10

Campaign Efficiency Metrics:
Click-Through Rate (CTR):      =SUM(Clicks_Data!B:B)/SUM(Impressions_Data!B:B)
Conversion Rate:               =SUM(Conversions_Data!B:B)/SUM(Clicks_Data!B:B)
Cost Per Click (CPC):          =B3/SUM(Clicks_Data!B:B)
Cost Per Thousand (CPM):       =B3/SUM(Impressions_Data!B:B)*1000

{{#if (eq business_model "b2b-saas")}}
Lead Quality Metrics:
Marketing Qualified Leads:     =MQL_Data!B1
Sales Qualified Leads:        =SQL_Data!B1
MQL to SQL Conversion:         =B12/B11
Pipeline Value:                =Pipeline_Data!B1
Sales Cycle (Days):            =AVERAGE(Sales_Cycle_Data!B:B)
{{else if (eq business_model "b2c-ecommerce")}}
E-commerce Metrics:
Average Order Value (AOV):     =B4/SUM(Orders_Data!B:B)
Purchase Frequency:            =AVERAGE(Frequency_Data!B:B)
Cart Abandonment Rate:         =Cart_Abandon_Data!B1
Return Customer Rate:          =Returning_Customers!B1/Total_Customers!B1
{{/if}}

Channel Performance Summary:
Best Performing Channel:       =INDEX(Channel_Names,MATCH(MAX(Channel_ROAS),Channel_ROAS,0))
Highest Volume Channel:        =INDEX(Channel_Names,MATCH(MAX(Channel_Spend),Channel_Spend,0))
Most Efficient Channel:        =INDEX(Channel_Names,MATCH(MIN(Channel_CPA),Channel_CPA,0))
```

### Campaign Data Structure
```excel
=== CAMPAIGN DATA ===

Date        Channel    Campaign        Spend    Impressions  Clicks   Conversions  Revenue
2024-01-01  Google     Brand-Search    1500     50000        2500     125          3750
2024-01-01  Facebook   Lookalike-1     2000     100000       3000     90           4500  
2024-01-01  Email      Newsletter      500      25000        1250     200          8000
2024-01-01  LinkedIn   B2B-Targeting   3000     20000        400      25           5000

Calculated Metrics:
CTR:        =E2/D2                    // Click-through rate
CVR:        =F2/E2                    // Conversion rate  
CPC:        =C2/E2                    // Cost per click
CPA:        =C2/F2                    // Cost per acquisition
ROAS:       =G2/C2                    // Return on ad spend
CPM:        =(C2/D2)*1000             // Cost per thousand impressions
```

### Attribution Analysis
```excel
=== ATTRIBUTION ANALYSIS ===

{{#if (eq attribution_model "multi-touch")}}
Multi-Touch Attribution Model:
Conversion Path Analysis:
Path                                    Conversions   Revenue    Attribution Weight
Google > Facebook > Email               150          15000      First: 40%, Middle: 20%, Last: 40%
Facebook > Google > Direct              120          18000      First: 40%, Middle: 20%, Last: 40%  
Email > Google > Facebook               100          12000      First: 40%, Middle: 20%, Last: 40%

Channel Attribution Credits:
Channel        First Touch   Middle Touch   Last Touch   Total Credit   Weighted Revenue
Google         2000         800            1600         4400          44000
Facebook       1800         600            1200         3600          36000
Email          1200         400            800          2400          24000
Direct         800          200            900          1900          19000

{{else if (eq attribution_model "data-driven")}}
Data-Driven Attribution (Machine Learning):
Channel Contribution Analysis:
Channel        Baseline Conv.  Incremental   Attribution   Adj. Revenue
Google         500            300           35%           35000
Facebook       400            250           30%           30000  
Email          300            200           25%           25000
LinkedIn       150            100           10%           10000

Model Performance:
Attribution Model Accuracy:     85%
Cross-Validation Score:         0.82
Feature Importance:
- Time to conversion:           23%
- Touch sequence:              19%  
- Channel interaction:         18%
- Seasonality:                 15%
- Audience segment:            14%
- Creative type:               11%
{{/if}}
```

---

## 2. Python Analytics Implementation

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

class MarketingCampaignAnalyzer:
    def __init__(self, campaign_type: str, business_model: str):
        self.campaign_type = campaign_type
        self.business_model = business_model
        self.campaign_data = pd.DataFrame()
        self.customer_data = pd.DataFrame()
        self.attribution_data = pd.DataFrame()
        
    def load_campaign_data(self, file_path: str = None, sample_data: bool = True):
        """Load or generate campaign performance data"""
        
        if sample_data:
            # Generate sample campaign data
            np.random.seed(42)
            date_range = pd.date_range('2024-01-01', '2024-12-31', freq='D')
            
            channels = {
                'digital-ads': ['Google Ads', 'Facebook', 'Instagram', 'LinkedIn', 'Twitter'],
                'email': ['Newsletter', 'Promotional', 'Drip Campaign', 'Re-engagement'],
                'social-media': ['Facebook', 'Instagram', 'LinkedIn', 'Twitter', 'TikTok'],
                'content': ['Blog', 'Video', 'Podcast', 'Webinar', 'Whitepaper'],
                'seo': ['Organic Search', 'Local SEO', 'Content SEO', 'Technical SEO'],
                'mixed-channel': ['Google Ads', 'Facebook', 'Email', 'Organic', 'Direct']
            }
            
            campaign_channels = channels.get(self.campaign_type, ['Channel 1', 'Channel 2', 'Channel 3'])
            
            data = []
            for date in date_range:
                for channel in campaign_channels:
                    # Generate realistic campaign metrics based on business model
                    if self.business_model == 'b2b-saas':
                        spend = np.random.gamma(2, 500)  # Higher spend, lower volume
                        impressions = np.random.gamma(2, 5000)
                        ctr = np.random.beta(2, 98) * 0.05  # Lower CTR for B2B
                        cvr = np.random.beta(5, 95) * 0.15  # Higher CVR for qualified traffic
                        aov = np.random.gamma(3, 1000)  # Higher AOV for B2B
                    else:  # b2c-ecommerce
                        spend = np.random.gamma(2, 200)
                        impressions = np.random.gamma(2, 10000)
                        ctr = np.random.beta(3, 97) * 0.08  # Higher CTR for B2C
                        cvr = np.random.beta(2, 98) * 0.05  # Lower CVR but higher volume
                        aov = np.random.gamma(2, 50)   # Lower AOV for B2C
                    
                    clicks = impressions * ctr
                    conversions = clicks * cvr
                    revenue = conversions * aov
                    
                    # Add seasonality and day-of-week effects
                    seasonal_multiplier = 1 + 0.3 * np.sin(2 * np.pi * date.dayofyear / 365)
                    weekday_multiplier = 1.2 if date.weekday() < 5 else 0.8
                    
                    data.append({
                        'date': date,
                        'channel': channel,
                        'spend': spend * seasonal_multiplier * weekday_multiplier,
                        'impressions': impressions * seasonal_multiplier * weekday_multiplier,
                        'clicks': clicks * seasonal_multiplier * weekday_multiplier,
                        'conversions': conversions * seasonal_multiplier * weekday_multiplier,
                        'revenue': revenue * seasonal_multiplier * weekday_multiplier
                    })
            
            self.campaign_data = pd.DataFrame(data)
            
            # Calculate derived metrics
            self.campaign_data['ctr'] = self.campaign_data['clicks'] / self.campaign_data['impressions']
            self.campaign_data['cvr'] = self.campaign_data['conversions'] / self.campaign_data['clicks']
            self.campaign_data['cpc'] = self.campaign_data['spend'] / self.campaign_data['clicks']
            self.campaign_data['cpa'] = self.campaign_data['spend'] / self.campaign_data['conversions']
            self.campaign_data['roas'] = self.campaign_data['revenue'] / self.campaign_data['spend']
            self.campaign_data['cpm'] = (self.campaign_data['spend'] / self.campaign_data['impressions']) * 1000
            
            # Clean infinities and NaNs
            self.campaign_data = self.campaign_data.replace([np.inf, -np.inf], np.nan).fillna(0)
            
        else:
            self.campaign_data = pd.read_csv(file_path)
            
        print(f"Loaded campaign data: {len(self.campaign_data)} records")
        return self.campaign_data
        
    def performance_overview(self):
        """Generate comprehensive performance overview"""
        print("ðŸ“Š CAMPAIGN PERFORMANCE OVERVIEW")
        print("=" * 50)
        
        # Overall metrics
        total_spend = self.campaign_data['spend'].sum()
        total_revenue = self.campaign_data['revenue'].sum()
        total_conversions = self.campaign_data['conversions'].sum()
        overall_roas = total_revenue / total_spend if total_spend > 0 else 0
        
        print(f"Campaign Type: {self.campaign_type.title()}")
        print(f"Business Model: {self.business_model.upper()}")
        print(f"Analysis Period: {self.campaign_data['date'].min()} to {self.campaign_data['date'].max()}")
        print()
        print(f"ðŸ’° Total Spend: ${total_spend:,.0f}")
        print(f"ðŸ’µ Total Revenue: ${total_revenue:,.0f}")
        print(f"ðŸŽ¯ Total Conversions: {total_conversions:,.0f}")
        print(f"ðŸ“ˆ Overall ROAS: {overall_roas:.2f}x")
        print(f"ðŸ’¸ Average CPA: ${total_spend/total_conversions if total_conversions > 0 else 0:.2f}")
        print()
        
        # Channel performance summary
        channel_summary = self.campaign_data.groupby('channel').agg({
            'spend': 'sum',
            'revenue': 'sum',
            'conversions': 'sum',
            'impressions': 'sum',
            'clicks': 'sum'
        }).round(0)
        
        channel_summary['roas'] = (channel_summary['revenue'] / channel_summary['spend']).round(2)
        channel_summary['cpa'] = (channel_summary['spend'] / channel_summary['conversions']).round(2)
        channel_summary['ctr'] = (channel_summary['clicks'] / channel_summary['impressions'] * 100).round(2)
        
        print("CHANNEL PERFORMANCE SUMMARY:")
        print(channel_summary.sort_values('roas', ascending=False))
        
        return channel_summary
        
    def create_performance_visualizations(self):
        """Create comprehensive performance visualizations"""
        
        # Set up subplot structure
        fig = make_subplots(
            rows=3, cols=2,
            subplot_titles=('Daily Spend & Revenue', 'Channel ROAS Comparison', 
                          'Conversion Trends', 'Cost Efficiency Matrix',
                          'Attribution Flow', 'Performance Correlation'),
            specs=[[{"secondary_y": True}, {}],
                   [{"secondary_y": True}, {}],
                   [{}, {}]]
        )
        
        # 1. Daily spend and revenue trends
        daily_data = self.campaign_data.groupby('date').agg({
            'spend': 'sum',
            'revenue': 'sum',
            'conversions': 'sum'
        }).reset_index()
        
        fig.add_trace(
            go.Scatter(x=daily_data['date'], y=daily_data['spend'], 
                      name='Daily Spend', line=dict(color='red')),
            row=1, col=1
        )
        fig.add_trace(
            go.Scatter(x=daily_data['date'], y=daily_data['revenue'], 
                      name='Daily Revenue', line=dict(color='green')),
            row=1, col=1, secondary_y=True
        )
        
        # 2. Channel ROAS comparison
        channel_roas = self.campaign_data.groupby('channel').agg({
            'revenue': 'sum',
            'spend': 'sum'
        })
        channel_roas['roas'] = channel_roas['revenue'] / channel_roas['spend']
        
        fig.add_trace(
            go.Bar(x=channel_roas.index, y=channel_roas['roas'], 
                  name='ROAS by Channel', marker_color='blue'),
            row=1, col=2
        )
        
        # 3. Conversion trends by channel
        weekly_conversions = self.campaign_data.copy()
        weekly_conversions['week'] = weekly_conversions['date'].dt.isocalendar().week
        weekly_conv = weekly_conversions.groupby(['week', 'channel'])['conversions'].sum().reset_index()
        
        for channel in weekly_conv['channel'].unique():
            channel_data = weekly_conv[weekly_conv['channel'] == channel]
            fig.add_trace(
                go.Scatter(x=channel_data['week'], y=channel_data['conversions'],
                          name=f'{channel} Conversions', mode='lines+markers'),
                row=2, col=1
            )
        
        # 4. Cost efficiency matrix (CPA vs Volume)
        channel_efficiency = self.campaign_data.groupby('channel').agg({
            'conversions': 'sum',
            'spend': 'sum'
        })
        channel_efficiency['cpa'] = channel_efficiency['spend'] / channel_efficiency['conversions']
        
        fig.add_trace(
            go.Scatter(x=channel_efficiency['conversions'], y=channel_efficiency['cpa'],
                      mode='markers+text', text=channel_efficiency.index,
                      textposition="top center", name='Channel Efficiency',
                      marker=dict(size=10, color='orange')),
            row=2, col=2
        )
        
        # Update layout
        fig.update_layout(
            height=1200,
            title_text=f"Marketing Campaign Analysis Dashboard - {self.campaign_type.title()}",
            showlegend=True
        )
        
        fig.show()
        
        # Additional visualization: Monthly performance heatmap
        monthly_data = self.campaign_data.copy()
        monthly_data['month'] = monthly_data['date'].dt.month
        monthly_data['channel_month'] = monthly_data['channel'] + '_' + monthly_data['month'].astype(str)
        
        monthly_performance = monthly_data.groupby(['month', 'channel']).agg({
            'roas': 'mean',
            'spend': 'sum'
        }).reset_index()
        
        # Create heatmap
        heatmap_data = monthly_performance.pivot(index='channel', columns='month', values='roas')
        
        plt.figure(figsize=(12, 8))
        sns.heatmap(heatmap_data, annot=True, fmt='.2f', cmap='RdYlGn', center=1)
        plt.title('Monthly ROAS Heatmap by Channel')
        plt.xlabel('Month')
        plt.ylabel('Channel')
        plt.tight_layout()
        plt.show()
        
    {{#if includes_cohort_analysis}}
    def cohort_analysis(self):
        """Perform customer cohort analysis for LTV calculation"""
        print("\nðŸ“ˆ COHORT ANALYSIS")
        print("-" * 30)
        
        # Generate sample customer data for cohort analysis
        np.random.seed(42)
        customers = []
        
        for i in range(int(self.campaign_data['conversions'].sum())):
            # Random acquisition date weighted by campaign performance
            acq_date = np.random.choice(self.campaign_data['date'])
            acq_channel = np.random.choice(self.campaign_data['channel'], 
                                         p=self.campaign_data.groupby('channel')['conversions'].sum().values / 
                                         self.campaign_data['conversions'].sum())
            
            # Generate customer lifecycle data
            if self.business_model == 'b2b-saas':
                # B2B SaaS typically has monthly recurring revenue
                monthly_revenue = np.random.gamma(2, 100)  # $200 average
                churn_probability = 0.05  # 5% monthly churn
                avg_lifetime_months = int(np.random.exponential(20))  # ~20 month average
            else:
                # B2C e-commerce has more irregular purchase patterns
                monthly_revenue = np.random.gamma(1, 30)   # $30 average
                churn_probability = 0.15  # 15% monthly churn  
                avg_lifetime_months = int(np.random.exponential(8))   # ~8 month average
            
            customers.append({
                'customer_id': f'C{i:06d}',
                'acquisition_date': acq_date,
                'acquisition_channel': acq_channel,
                'monthly_revenue': monthly_revenue,
                'lifetime_months': max(1, avg_lifetime_months),
                'total_revenue': monthly_revenue * max(1, avg_lifetime_months)
            })
        
        cohort_data = pd.DataFrame(customers)
        
        # Calculate cohort metrics
        cohort_data['acquisition_month'] = cohort_data['acquisition_date'].dt.to_period('M')
        
        cohort_metrics = cohort_data.groupby(['acquisition_month', 'acquisition_channel']).agg({
            'total_revenue': ['mean', 'sum', 'count'],
            'lifetime_months': 'mean',
            'monthly_revenue': 'mean'
        }).round(2)
        
        # Calculate CLV by channel
        clv_by_channel = cohort_data.groupby('acquisition_channel').agg({
            'total_revenue': 'mean',
            'lifetime_months': 'mean',
            'monthly_revenue': 'mean'
        }).round(2)
        
        clv_by_channel.columns = ['Average_CLV', 'Avg_Lifetime_Months', 'Avg_Monthly_Revenue']
        
        print("CUSTOMER LIFETIME VALUE BY CHANNEL:")
        print(clv_by_channel)
        
        # Calculate LTV:CAC ratios
        campaign_cpa = self.campaign_data.groupby('channel').agg({
            'spend': 'sum',
            'conversions': 'sum'
        })
        campaign_cpa['cpa'] = campaign_cpa['spend'] / campaign_cpa['conversions']
        
        ltv_cac = pd.merge(clv_by_channel, campaign_cpa[['cpa']], left_index=True, right_index=True)
        ltv_cac['ltv_cac_ratio'] = ltv_cac['Average_CLV'] / ltv_cac['cpa']
        
        print(f"\nLTV:CAC RATIOS BY CHANNEL:")
        print(ltv_cac[['Average_CLV', 'cpa', 'ltv_cac_ratio']].round(2))
        
        # Visualize cohort performance
        plt.figure(figsize=(15, 10))
        
        plt.subplot(2, 2, 1)
        clv_by_channel['Average_CLV'].plot(kind='bar', color='green', alpha=0.7)
        plt.title('Average Customer Lifetime Value by Channel')
        plt.xticks(rotation=45)
        plt.ylabel('CLV ($)')
        
        plt.subplot(2, 2, 2)
        ltv_cac['ltv_cac_ratio'].plot(kind='bar', color='blue', alpha=0.7)
        plt.title('LTV:CAC Ratio by Channel')
        plt.axhline(y=3, color='red', linestyle='--', alpha=0.7, label='Target: 3:1')
        plt.xticks(rotation=45)
        plt.ylabel('LTV:CAC Ratio')
        plt.legend()
        
        plt.subplot(2, 2, 3)
        clv_by_channel['Avg_Lifetime_Months'].plot(kind='bar', color='orange', alpha=0.7)
        plt.title('Average Customer Lifetime (Months)')
        plt.xticks(rotation=45)
        plt.ylabel('Months')
        
        plt.subplot(2, 2, 4)
        # Monthly cohorts over time
        monthly_cohorts = cohort_data.groupby('acquisition_month')['total_revenue'].mean()
        monthly_cohorts.plot(kind='line', marker='o', color='purple')
        plt.title('Average CLV by Acquisition Month')
        plt.xticks(rotation=45)
        plt.ylabel('CLV ($)')
        
        plt.tight_layout()
        plt.show()
        
        return ltv_cac, cohort_data
    {{/if}}
    
    def audience_segmentation(self):
        """Perform audience segmentation analysis"""
        print("\nðŸ‘¥ AUDIENCE SEGMENTATION ANALYSIS")  
        print("-" * 40)
        
        # Create audience segments based on channel performance patterns
        channel_features = self.campaign_data.groupby('channel').agg({
            'ctr': 'mean',
            'cvr': 'mean', 
            'cpa': 'mean',
            'roas': 'mean',
            'spend': 'sum'
        }).fillna(0)
        
        # Standardize features for clustering
        scaler = StandardScaler()
        features_scaled = scaler.fit_transform(channel_features)
        
        # Perform K-means clustering
        kmeans = KMeans(n_clusters=3, random_state=42)
        channel_features['segment'] = kmeans.fit_predict(features_scaled)
        
        # Define segment characteristics
        segments = {
            0: 'High-Volume, Low-Efficiency',
            1: 'Balanced Performance', 
            2: 'High-Efficiency, Low-Volume'
        }
        
        # Assign descriptive names based on characteristics
        for segment_id in channel_features['segment'].unique():
            segment_data = channel_features[channel_features['segment'] == segment_id]
            avg_roas = segment_data['roas'].mean()
            avg_spend = segment_data['spend'].mean()
            
            if avg_roas > channel_features['roas'].mean() and avg_spend < channel_features['spend'].mean():
                segments[segment_id] = 'High-Efficiency, Focused'
            elif avg_roas < channel_features['roas'].mean() and avg_spend > channel_features['spend'].mean():
                segments[segment_id] = 'High-Volume, Scale-Focused'
            else:
                segments[segment_id] = 'Balanced Performance'
        
        channel_features['segment_name'] = channel_features['segment'].map(segments)
        
        print("CHANNEL SEGMENTATION RESULTS:")
        for segment_id, segment_name in segments.items():
            segment_channels = channel_features[channel_features['segment'] == segment_id]
            if not segment_channels.empty:
                print(f"\n{segment_name.upper()}:")
                print(f"Channels: {', '.join(segment_channels.index.tolist())}")
                print(f"Average ROAS: {segment_channels['roas'].mean():.2f}")
                print(f"Average CPA: ${segment_channels['cpa'].mean():.2f}")
                print(f"Total Spend: ${segment_channels['spend'].sum():,.0f}")
        
        # Visualize segments
        plt.figure(figsize=(12, 8))
        
        scatter = plt.scatter(channel_features['roas'], channel_features['spend'], 
                            c=channel_features['segment'], cmap='viridis', 
                            s=100, alpha=0.7)
        
        # Add channel labels
        for idx, row in channel_features.iterrows():
            plt.annotate(idx, (row['roas'], row['spend']), 
                        xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        plt.xlabel('ROAS')
        plt.ylabel('Total Spend ($)')
        plt.title('Channel Segmentation: ROAS vs Spend')
        plt.colorbar(scatter, label='Segment')
        
        # Add quadrant lines
        plt.axhline(y=channel_features['spend'].mean(), color='red', linestyle='--', alpha=0.5)
        plt.axvline(x=channel_features['roas'].mean(), color='red', linestyle='--', alpha=0.5)
        
        plt.tight_layout()
        plt.show()
        
        return channel_features
        
    def optimization_recommendations(self):
        """Generate optimization recommendations"""
        print("\nðŸ’¡ OPTIMIZATION RECOMMENDATIONS")
        print("-" * 40)
        
        # Channel performance analysis
        channel_summary = self.campaign_data.groupby('channel').agg({
            'spend': 'sum',
            'revenue': 'sum',
            'conversions': 'sum',
            'roas': 'mean',
            'cpa': 'mean'
        }).round(2)
        
        channel_summary['efficiency_score'] = (
            (channel_summary['roas'] / channel_summary['roas'].max()) * 0.4 +
            (1 - channel_summary['cpa'] / channel_summary['cpa'].max()) * 0.4 +
            (channel_summary['conversions'] / channel_summary['conversions'].max()) * 0.2
        )
        
        recommendations = []
        
        # Budget reallocation recommendations
        best_performer = channel_summary.loc[channel_summary['efficiency_score'].idxmax()]
        worst_performer = channel_summary.loc[channel_summary['efficiency_score'].idxmin()]
        
        recommendations.append({
            'priority': 'HIGH',
            'category': 'Budget Reallocation',
            'recommendation': f'Increase budget for {best_performer.name} (ROAS: {best_performer["roas"]:.2f}) and consider reducing spend on {worst_performer.name} (ROAS: {worst_performer["roas"]:.2f})',
            'impact': 'Immediate ROAS improvement'
        })
        
        # Channel-specific recommendations
        for channel, data in channel_summary.iterrows():
            if data['roas'] < 2.0:  # Low ROAS threshold
                recommendations.append({
                    'priority': 'HIGH',
                    'category': 'Performance Optimization',
                    'recommendation': f'{channel}: ROAS below target (2.0x). Review targeting, creative, or landing pages',
                    'impact': f'Potential revenue increase: ${(data["spend"] * 1.0):,.0f}'
                })
            
            if data['cpa'] > channel_summary['cpa'].mean() * 1.5:  # High CPA
                recommendations.append({
                    'priority': 'MEDIUM',
                    'category': 'Cost Efficiency',
                    'recommendation': f'{channel}: CPA (${data["cpa"]:.2f}) significantly above average. Optimize for conversion efficiency',
                    'impact': 'Reduce acquisition costs'
                })
        
        # Seasonality recommendations
        monthly_performance = self.campaign_data.groupby(self.campaign_data['date'].dt.month).agg({
            'spend': 'sum',
            'revenue': 'sum',
            'roas': 'mean'
        })
        
        best_months = monthly_performance.nlargest(3, 'roas').index.tolist()
        recommendations.append({
            'priority': 'MEDIUM',
            'category': 'Seasonal Optimization',
            'recommendation': f'Focus budget on high-performing months: {", ".join([f"Month {m}" for m in best_months])}',
            'impact': 'Capitalize on seasonal trends'
        })
        
        # Display recommendations
        for i, rec in enumerate(recommendations, 1):
            print(f"{i}. [{rec['priority']}] {rec['category']}:")
            print(f"   {rec['recommendation']}")
            print(f"   Expected Impact: {rec['impact']}")
            print()
        
        return recommendations
        
    def generate_executive_report(self):
        """Generate comprehensive executive report"""
        print("\nðŸ“‹ EXECUTIVE CAMPAIGN REPORT")
        print("=" * 60)
        
        # Key metrics
        total_spend = self.campaign_data['spend'].sum()
        total_revenue = self.campaign_data['revenue'].sum()
        total_conversions = self.campaign_data['conversions'].sum()
        overall_roas = total_revenue / total_spend if total_spend > 0 else 0
        
        print(f"Campaign Period: {self.campaign_data['date'].min().strftime('%Y-%m-%d')} to {self.campaign_data['date'].max().strftime('%Y-%m-%d')}")
        print(f"Campaign Type: {self.campaign_type.title()}")
        print(f"Business Model: {self.business_model.upper()}")
        print()
        
        # Performance summary
        print("CAMPAIGN PERFORMANCE SUMMARY:")
        print(f"â€¢ Total Investment: ${total_spend:,.0f}")
        print(f"â€¢ Total Revenue Generated: ${total_revenue:,.0f}")
        print(f"â€¢ Return on Ad Spend: {overall_roas:.2f}x")
        print(f"â€¢ Total Conversions: {total_conversions:,.0f}")
        print(f"â€¢ Cost Per Acquisition: ${total_spend/total_conversions if total_conversions > 0 else 0:.2f}")
        print()
        
        # Top performing channels
        top_channels = self.campaign_data.groupby('channel').agg({
            'revenue': 'sum',
            'spend': 'sum'
        })
        top_channels['roas'] = top_channels['revenue'] / top_channels['spend']
        top_3 = top_channels.nlargest(3, 'roas')
        
        print("TOP PERFORMING CHANNELS:")
        for i, (channel, data) in enumerate(top_3.iterrows(), 1):
            print(f"{i}. {channel}: {data['roas']:.2f}x ROAS, ${data['revenue']:,.0f} revenue")
        
        print()
        
        # Key insights
        print("KEY INSIGHTS:")
        avg_roas = top_channels['roas'].mean()
        if overall_roas > avg_roas * 1.2:
            print("â€¢ Campaign is performing above industry benchmarks")
        elif overall_roas < avg_roas * 0.8:
            print("â€¢ Campaign underperforming - optimization needed")
        else:
            print("â€¢ Campaign performing within expected range")
            
        # Channel diversity
        revenue_concentration = (top_channels['revenue'].max() / top_channels['revenue'].sum()) * 100
        if revenue_concentration > 70:
            print(f"â€¢ High dependency on single channel ({revenue_concentration:.0f}% of revenue)")
        else:
            print("â€¢ Well-diversified channel mix")
            
        print("\n" + "=" * 60)

# Example Usage and Execution
if __name__ == "__main__":
    # Initialize analyzer
    analyzer = MarketingCampaignAnalyzer('{{campaign_type}}', '{{business_model}}')
    
    # Load data (sample data for demonstration)
    campaign_data = analyzer.load_campaign_data(sample_data=True)
    
    # Generate comprehensive analysis
    print("ðŸš€ Starting Marketing Campaign Analysis...")
    print()
    
    # 1. Performance Overview
    channel_summary = analyzer.performance_overview()
    
    # 2. Create Visualizations
    analyzer.create_performance_visualizations()
    
    {{#if includes_cohort_analysis}}
    # 3. Cohort Analysis
    ltv_cac, cohort_data = analyzer.cohort_analysis()
    {{/if}}
    
    # 4. Audience Segmentation
    channel_segments = analyzer.audience_segmentation()
    
    # 5. Optimization Recommendations  
    recommendations = analyzer.optimization_recommendations()
    
    # 6. Executive Report
    analyzer.generate_executive_report()
    
    print("\nâœ… Analysis Complete!")
    print("ðŸ“Š Check generated visualizations for detailed insights")
```

---

## Key Marketing Metrics & KPIs

### Acquisition Metrics
- **Cost Per Click (CPC):** Ad Spend Ã· Clicks
- **Click-Through Rate (CTR):** Clicks Ã· Impressions  
- **Conversion Rate (CVR):** Conversions Ã· Clicks
- **Cost Per Acquisition (CPA):** Ad Spend Ã· Conversions
- **Return on Ad Spend (ROAS):** Revenue Ã· Ad Spend

### Customer Value Metrics
{{#if includes_cohort_analysis}}
- **Customer Lifetime Value (CLV):** Average Revenue Ã— Lifetime Periods
- **LTV:CAC Ratio:** Customer Lifetime Value Ã· Customer Acquisition Cost
- **Payback Period:** Customer Acquisition Cost Ã· Monthly Revenue
- **Cohort Retention:** % of customers active after N periods
{{/if}}

### Business Impact Metrics
{{#if (eq business_model "b2b-saas")}}
- **Marketing Qualified Leads (MQL):** Leads meeting qualification criteria  
- **Sales Qualified Leads (SQL):** MQLs accepted by sales team
- **MQL to SQL Conversion:** SQLs Ã· MQLs
- **Pipeline Value:** Total potential revenue in sales pipeline
- **Sales Cycle Length:** Average days from lead to close
{{else if (eq business_model "b2c-ecommerce")}}
- **Average Order Value (AOV):** Total Revenue Ã· Number of Orders
- **Purchase Frequency:** Orders per Customer per Period  
- **Cart Abandonment Rate:** Abandoned Carts Ã· Total Carts Created
- **Repeat Purchase Rate:** Repeat Customers Ã· Total Customers
{{/if}}

---

## Attribution Model Implementation

### Multi-Touch Attribution
```python
# Attribution weights for customer journey
attribution_weights = {
    'first_touch': 0.4,    # First interaction gets 40%
    'middle_touch': 0.2,   # Middle interactions split 20%
    'last_touch': 0.4      # Last interaction gets 40%
}

def calculate_attribution(customer_journey):
    """Calculate multi-touch attribution for customer journey"""
    touchpoints = len(customer_journey)
    
    if touchpoints == 1:
        return {customer_journey[0]: 1.0}
    elif touchpoints == 2:
        return {
            customer_journey[0]: attribution_weights['first_touch'],
            customer_journey[1]: attribution_weights['last_touch']
        }
    else:
        middle_weight = attribution_weights['middle_touch'] / (touchpoints - 2)
        attribution = {}
        
        # First touch
        attribution[customer_journey[0]] = attribution_weights['first_touch']
        
        # Middle touches
        for i in range(1, touchpoints - 1):
            channel = customer_journey[i]
            if channel in attribution:
                attribution[channel] += middle_weight
            else:
                attribution[channel] = middle_weight
                
        # Last touch
        last_channel = customer_journey[-1]
        if last_channel in attribution:
            attribution[last_channel] += attribution_weights['last_touch']
        else:
            attribution[last_channel] = attribution_weights['last_touch']
            
        return attribution
```

---

## Campaign Optimization Strategies

### Budget Allocation Optimization
1. **Performance-Based Allocation:**
   - Allocate budget proportional to ROAS performance
   - Set minimum performance thresholds
   - Regular rebalancing based on results

2. **Marginal ROI Analysis:**
   - Calculate diminishing returns for each channel
   - Identify optimal spend levels
   - Shift budget to highest marginal ROI opportunities

### Creative and Targeting Optimization
{{#if (eq campaign_type "digital-ads")}}
- **A/B Test Creative Variations:** Headlines, images, CTAs
- **Audience Refinement:** Demographics, interests, behaviors  
- **Bid Strategy Optimization:** Manual vs automated bidding
- **Ad Placement Testing:** Feed vs stories vs audience network
{{else if (eq campaign_type "email")}}
- **Subject Line Testing:** Open rate optimization
- **Send Time Optimization:** Day/time performance analysis
- **List Segmentation:** Demographic and behavioral segments
- **Content Personalization:** Dynamic content based on user data
{{/if}}

### Seasonal and Trend Optimization
- **Historical Seasonality Analysis:** Identify peak performance periods
- **Trend Monitoring:** Adjust campaigns based on market trends
- **Competitive Intelligence:** Monitor competitor campaign activity
- **Budget Pacing:** Accelerate/decelerate spend based on performance

---

## Reporting and Dashboard Setup

### Automated Reporting Schedule
- **Daily:** Spend, revenue, conversions by channel
- **Weekly:** Performance trends, optimization opportunities  
- **Monthly:** ROI analysis, attribution insights, strategic recommendations
- **Quarterly:** Campaign effectiveness review, budget planning

### Key Stakeholder Dashboards
{{#if (eq business_model "b2b-saas")}}
**CMO Dashboard:**
- Overall ROAS and pipeline contribution
- Channel performance comparison
- Lead quality metrics (MQL/SQL rates)
- Customer acquisition cost trends

**Performance Marketing Dashboard:**  
- Real-time campaign performance
- Budget utilization and pacing
- Conversion funnel analysis
- Creative performance metrics
{{else if (eq business_model "b2c-ecommerce")}}
**Executive Dashboard:**
- Revenue and ROAS overview
- Customer lifetime value trends  
- Market share and competitive position
- Seasonal performance patterns

**Marketing Operations Dashboard:**
- Campaign performance by channel
- Budget allocation and efficiency
- Customer acquisition metrics
- Retention and repeat purchase rates
{{/if}}

Remember: This analysis framework should be customized based on your specific business goals, available data sources, and organizational requirements. Regular review and optimization of both campaigns and analysis methodologies is essential for sustained performance improvement.