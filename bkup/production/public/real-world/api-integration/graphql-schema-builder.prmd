---
id: graphql-schema-builder
name: GraphQL Schema & Resolver Builder
version: 1.0.0
description: Generates complete GraphQL schemas with resolvers, subscriptions, and security
tags: [graphql, api, schema, resolvers]
parameters:
  - name: service_name
    type: string
    required: true
    description: Name of the GraphQL service (e.g., "User Service", "E-commerce API")
  - name: primary_entity
    type: string
    required: true
    description: Main entity name (e.g., "User", "Product", "Order")
  - name: framework
    type: string
    enum: [apollo-server, graphql-yoga, express-graphql, strawberry, ariadne, gqlgen]
    required: true
    description: GraphQL framework to use
  - name: database
    type: string
    enum: [mongodb, postgresql, mysql, sqlite, prisma]
    required: true
    description: Database or ORM
  - name: real_time_features
    type: boolean
    default: false
    description: Include subscriptions for real-time updates
  - name: auth_strategy
    type: string
    enum: [jwt, session, api-key, none]
    default: jwt
    description: Authentication strategy
  - name: include_mutations
    type: boolean
    default: true
    description: Include create, update, delete mutations
---

# GraphQL Schema Builder: {{service_name}}

## Implementation Requirements

Build a complete GraphQL API for **{{primary_entity}}** management using **{{framework}}** with **{{database}}** persistence.

### Core Specifications:
- **Framework:** {{framework}}
- **Database:** {{database}}
- **Authentication:** {{auth_strategy}}
- **Real-time:** {{#if real_time_features}}Subscriptions enabled{{else}}Query/Mutation only{{/if}}
- **Mutations:** {{#if include_mutations}}Enabled{{else}}Read-only{{/if}}

## Schema Architecture

### 1. Core Type Definition
```graphql
type {{primary_entity}} {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  # Add entity-specific fields here
}

type {{primary_entity}}Connection {
  edges: [{{primary_entity}}Edge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type {{primary_entity}}Edge {
  node: {{primary_entity}}!
  cursor: String!
}

input {{primary_entity}}Filter {
  # Filtering options
  AND: [{{primary_entity}}Filter]
  OR: [{{primary_entity}}Filter]
}

input {{primary_entity}}Sort {
  field: {{primary_entity}}SortField!
  direction: SortDirection!
}

enum {{primary_entity}}SortField {
  CREATED_AT
  UPDATED_AT
  # Add sortable fields
}

enum SortDirection {
  ASC
  DESC
}
```

### 2. Query Operations
```graphql
type Query {
  # Single entity
  {{lower primary_entity}}(id: ID!): {{primary_entity}}
  
  # List with cursor pagination
  {{lower primary_entity}}s(
    first: Int
    after: String
    last: Int
    before: String
    filter: {{primary_entity}}Filter
    sort: {{primary_entity}}Sort
  ): {{primary_entity}}Connection!
  
  # Search functionality
  search{{primary_entity}}s(query: String!, limit: Int = 10): [{{primary_entity}}!]!
  
  # Aggregations
  {{lower primary_entity}}Stats: {{primary_entity}}Stats!
}

type {{primary_entity}}Stats {
  total: Int!
  # Add relevant statistics
}
```

{{#if include_mutations}}
### 3. Mutation Operations
```graphql
type Mutation {
  # Create
  create{{primary_entity}}(input: Create{{primary_entity}}Input!): {{primary_entity}}Payload!
  
  # Update
  update{{primary_entity}}(id: ID!, input: Update{{primary_entity}}Input!): {{primary_entity}}Payload!
  
  # Delete
  delete{{primary_entity}}(id: ID!): Delete{{primary_entity}}Payload!
  
  # Batch operations
  create{{primary_entity}}s(input: [Create{{primary_entity}}Input!]!): [{{primary_entity}}Payload!]!
  delete{{primary_entity}}s(ids: [ID!]!): BatchDeletePayload!
}

input Create{{primary_entity}}Input {
  # Required fields for creation
}

input Update{{primary_entity}}Input {
  # Optional fields for updates
}

type {{primary_entity}}Payload {
  {{lower primary_entity}}: {{primary_entity}}
  errors: [UserError!]!
}

type Delete{{primary_entity}}Payload {
  deletedId: ID
  errors: [UserError!]!
}

type BatchDeletePayload {
  deletedIds: [ID!]!
  errors: [UserError!]!
}

type UserError {
  field: String
  message: String!
  code: String!
}
```
{{/if}}

{{#if real_time_features}}
### 4. Subscription Operations
```graphql
type Subscription {
  # Entity changes
  {{lower primary_entity}}Changed(id: ID): {{primary_entity}}ChangePayload!
  
  # New entities
  {{lower primary_entity}}Added: {{primary_entity}}!
  
  # Deleted entities
  {{lower primary_entity}}Deleted(id: ID): ID!
  
  # Collection changes
  {{lower primary_entity}}sUpdated(filter: {{primary_entity}}Filter): {{primary_entity}}CollectionPayload!
}

type {{primary_entity}}ChangePayload {
  mutation: MutationType!
  node: {{primary_entity}}
  previousValues: {{primary_entity}}PreviousValues
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type {{primary_entity}}PreviousValues {
  # Previous values for change tracking
}

type {{primary_entity}}CollectionPayload {
  mutation: MutationType!
  node: {{primary_entity}}
}
```
{{/if}}

## Resolver Implementation

### 1. Query Resolvers
{{#if (eq framework "apollo-server")}}
```javascript
const resolvers = {
  Query: {
    {{lower primary_entity}}: async (parent, { id }, context) => {
      {{#if (ne auth_strategy "none")}}
      requireAuth(context);
      {{/if}}
      
      const {{lower primary_entity}} = await context.dataSources.{{lower primary_entity}}API.get{{primary_entity}}ById(id);
      if (!{{lower primary_entity}}) {
        throw new UserInputError(`{{primary_entity}} not found with id: ${id}`);
      }
      return {{lower primary_entity}};
    },

    {{lower primary_entity}}s: async (parent, args, context) => {
      {{#if (ne auth_strategy "none")}}
      requireAuth(context);
      {{/if}}
      
      return await context.dataSources.{{lower primary_entity}}API.get{{primary_entity}}s(args);
    },

    search{{primary_entity}}s: async (parent, { query, limit }, context) => {
      {{#if (ne auth_strategy "none")}}
      requireAuth(context);
      {{/if}}
      
      return await context.dataSources.{{lower primary_entity}}API.search{{primary_entity}}s(query, limit);
    }
  }
};
```
{{/if}}

{{#if include_mutations}}
### 2. Mutation Resolvers
```javascript
const mutationResolvers = {
  Mutation: {
    create{{primary_entity}}: async (parent, { input }, context) => {
      {{#if (ne auth_strategy "none")}}
      requireAuth(context);
      {{/if}}
      
      // Validation
      const validationErrors = validate{{primary_entity}}Input(input);
      if (validationErrors.length > 0) {
        return { {{lower primary_entity}}: null, errors: validationErrors };
      }

      try {
        const {{lower primary_entity}} = await context.dataSources.{{lower primary_entity}}API.create{{primary_entity}}(input);
        
        {{#if real_time_features}}
        // Publish subscription
        context.pubsub.publish('{{upper primary_entity}}_ADDED', {
          {{lower primary_entity}}Added: {{lower primary_entity}}
        });
        {{/if}}
        
        return { {{lower primary_entity}}, errors: [] };
      } catch (error) {
        return { 
          {{lower primary_entity}}: null, 
          errors: [{ message: error.message, code: 'CREATION_FAILED' }] 
        };
      }
    },

    update{{primary_entity}}: async (parent, { id, input }, context) => {
      {{#if (ne auth_strategy "none")}}
      requireAuth(context);
      await requireOwnership(context, '{{primary_entity}}', id);
      {{/if}}
      
      try {
        const {{lower primary_entity}} = await context.dataSources.{{lower primary_entity}}API.update{{primary_entity}}(id, input);
        
        {{#if real_time_features}}
        // Publish subscription
        context.pubsub.publish('{{upper primary_entity}}_CHANGED', {
          {{lower primary_entity}}Changed: {
            mutation: 'UPDATED',
            node: {{lower primary_entity}}
          }
        });
        {{/if}}
        
        return { {{lower primary_entity}}, errors: [] };
      } catch (error) {
        return { 
          {{lower primary_entity}}: null, 
          errors: [{ message: error.message, code: 'UPDATE_FAILED' }] 
        };
      }
    }
  }
};
```
{{/if}}

{{#if real_time_features}}
### 3. Subscription Resolvers
```javascript
const subscriptionResolvers = {
  Subscription: {
    {{lower primary_entity}}Added: {
      subscribe: (parent, args, context) => {
        {{#if (ne auth_strategy "none")}}
        requireAuth(context);
        {{/if}}
        return context.pubsub.asyncIterator('{{upper primary_entity}}_ADDED');
      }
    },

    {{lower primary_entity}}Changed: {
      subscribe: withFilter(
        (parent, args, context) => {
          {{#if (ne auth_strategy "none")}}
          requireAuth(context);
          {{/if}}
          return context.pubsub.asyncIterator('{{upper primary_entity}}_CHANGED');
        },
        (payload, variables) => {
          // Filter subscription based on variables
          return !variables.id || payload.{{lower primary_entity}}Changed.node.id === variables.id;
        }
      )
    }
  }
};
```
{{/if}}

## Data Source Implementation

{{#if (eq database "prisma")}}
### Prisma Data Source
```javascript
class {{primary_entity}}API extends DataSource {
  constructor() {
    super();
    this.prisma = new PrismaClient();
  }

  async get{{primary_entity}}ById(id) {
    return await this.prisma.{{lower primary_entity}}.findUnique({
      where: { id }
    });
  }

  async get{{primary_entity}}s({ first, after, filter, sort }) {
    const where = this.buildWhereClause(filter);
    const orderBy = this.buildOrderByClause(sort);
    
    const {{lower primary_entity}}s = await this.prisma.{{lower primary_entity}}.findMany({
      where,
      orderBy,
      take: first,
      skip: after ? 1 : 0,
      cursor: after ? { id: after } : undefined
    });

    const totalCount = await this.prisma.{{lower primary_entity}}.count({ where });
    
    return this.formatConnection({{lower primary_entity}}s, totalCount);
  }

  {{#if include_mutations}}
  async create{{primary_entity}}(input) {
    return await this.prisma.{{lower primary_entity}}.create({
      data: input
    });
  }

  async update{{primary_entity}}(id, input) {
    return await this.prisma.{{lower primary_entity}}.update({
      where: { id },
      data: input
    });
  }

  async delete{{primary_entity}}(id) {
    return await this.prisma.{{lower primary_entity}}.delete({
      where: { id }
    });
  }
  {{/if}}
}
```
{{/if}}

## Security Implementation

{{#if (eq auth_strategy "jwt")}}
### JWT Authentication
```javascript
const requireAuth = (context) => {
  if (!context.user) {
    throw new AuthenticationError('Authentication required');
  }
};

const requireOwnership = async (context, resource, resourceId) => {
  const resource = await context.dataSources[`${resource.toLowerCase()}API`].findById(resourceId);
  if (resource.userId !== context.user.id && !context.user.isAdmin) {
    throw new ForbiddenError('Access denied');
  }
};

// Context creation
const createContext = ({ req }) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  let user = null;
  
  if (token) {
    try {
      user = jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      // Invalid token - user remains null
    }
  }
  
  return {
    user,
    dataSources: {
      {{lower primary_entity}}API: new {{primary_entity}}API()
    }
  };
};
```
{{/if}}

### Input Validation
```javascript
const validate{{primary_entity}}Input = (input) => {
  const errors = [];
  
  // Add validation logic
  if (!input.name || input.name.trim().length < 2) {
    errors.push({
      field: 'name',
      message: 'Name must be at least 2 characters',
      code: 'VALIDATION_FAILED'
    });
  }
  
  return errors;
};
```

### Query Complexity Limiting
```javascript
import { createComplexityLimitRule } from 'graphql-query-complexity';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  validationRules: [createComplexityLimitRule(1000)],
  plugins: [
    // Depth limiting
    {
      requestParsed(requestContext) {
        const depth = calculateDepth(requestContext.request.query);
        if (depth > 10) {
          throw new UserInputError('Query too deep');
        }
      }
    }
  ]
});
```

## Performance Optimization

### 1. DataLoader for N+1 Prevention
```javascript
const createLoaders = () => ({
  {{lower primary_entity}}Loader: new DataLoader(async (ids) => {
    const {{lower primary_entity}}s = await {{primary_entity}}.findByIds(ids);
    return ids.map(id => {{lower primary_entity}}s.find(u => u.id === id));
  })
});
```

### 2. Query Optimization
- Implement field-level resolvers for expensive operations
- Use database indexes on commonly queried fields
- Cache frequently accessed data with Redis
- Implement query whitelisting for production

### 3. Subscription Optimization
{{#if real_time_features}}
- Use Redis PubSub for scaling across instances
- Implement subscription filtering at the database level
- Limit subscription connection count per user
- Use connection batching for high-frequency updates
{{/if}}

## Testing Strategy

### 1. Schema Testing
```javascript
describe('{{primary_entity}} Schema', () => {
  test('should fetch {{lower primary_entity}} by id', async () => {
    const query = `
      query Get{{primary_entity}}($id: ID!) {
        {{lower primary_entity}}(id: $id) {
          id
          # Add fields to test
        }
      }
    `;
    
    const result = await testServer.executeOperation({
      query,
      variables: { id: 'test-id' }
    });
    
    expect(result.errors).toBeUndefined();
    expect(result.data.{{lower primary_entity}}).toBeDefined();
  });
  
  {{#if include_mutations}}
  test('should create {{lower primary_entity}}', async () => {
    const mutation = `
      mutation Create{{primary_entity}}($input: Create{{primary_entity}}Input!) {
        create{{primary_entity}}(input: $input) {
          {{lower primary_entity}} {
            id
          }
          errors {
            message
            code
          }
        }
      }
    `;
    
    const result = await testServer.executeOperation({
      query: mutation,
      variables: { input: { /* test data */ } }
    });
    
    expect(result.data.create{{primary_entity}}.errors).toHaveLength(0);
    expect(result.data.create{{primary_entity}}.{{lower primary_entity}}).toBeDefined();
  });
  {{/if}}
});
```

## Deployment Checklist

### Production Setup:
- [ ] Query complexity limiting enabled
- [ ] Query depth limiting configured
- [ ] Rate limiting by IP and user
- [ ] Introspection disabled in production
- [ ] Query whitelisting implemented
- [ ] Authentication/authorization tested
- [ ] Error masking for security
- [ ] Performance monitoring setup

### Monitoring:
- [ ] Query performance metrics
- [ ] Resolver execution time tracking
- [ ] Error rate monitoring
- [ ] Authentication failure tracking
{{#if real_time_features}}
- [ ] Subscription connection metrics
- [ ] Real-time event delivery monitoring
{{/if}}

Remember: This GraphQL API is designed to be part of the Universal Interface Layer - ensure it's introspectable, well-documented, and follows GraphQL best practices for composability.