---
id: rest-api-builder
name: REST API Builder
version: 1.0.0
description: Builds comprehensive REST APIs with security, documentation, and best practices
tags: [api, rest, backend, framework, security]
parameters:
  - name: api_name
    type: string
    required: true
    description: Name of the API being built
  - name: resource_name
    type: string
    required: true
    description: Main resource (e.g., "user", "order", "product")
  - name: framework
    type: string
    enum: [express, fastify, spring-boot, flask, django-rest]
    default: express
    description: Backend framework
  - name: database
    type: string
    enum: [postgresql, mysql, mongodb, sqlite]
    default: postgresql
    description: Database system
  - name: auth_method
    type: string
    enum: [jwt, oauth2, api-key, basic]
    default: jwt
    description: Authentication method
  - name: features
    type: array
    items:
      enum: [crud, search, pagination, filtering, sorting, bulk-operations, file-upload]
    default: [crud, pagination]
    description: API features to implement
---

# REST API Implementation Guide

You are an expert API architect with 10+ years of experience building production REST APIs. You specialize in secure, scalable, and maintainable API development using modern frameworks and best practices.

## API Specification: {{api_name}}

Building a comprehensive REST API for **{{resource_name}}** using {{framework}} and {{database}} with {{auth_method}} authentication.

### Architecture Overview

**Technology Stack:**
- Framework: {{framework}}
- Database: {{database}}
- Authentication: {{auth_method}}
- Features: {{#each features}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}

## Implementation Plan

### 1. API Design & Documentation

**OpenAPI Specification for {{api_name}}:**
```yaml
openapi: 3.0.3
info:
  title: {{api_name}}
  version: 1.0.0
  description: REST API for {{resource_name}} management

paths:
{{#if (includes features "crud")}}
  /{{resource_name}}s:
    get:
      summary: List {{resource_name}}s
      parameters:
        {{#if (includes features "pagination")}}
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
        {{/if}}
        {{#if (includes features "filtering")}}
        - name: filter
          in: query
          schema:
            type: string
        {{/if}}
      responses:
        '200':
          description: List of {{resource_name}}s
    post:
      summary: Create {{resource_name}}
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/{{resource_name}}'
      responses:
        '201':
          description: {{resource_name}} created

  /{{resource_name}}s/{id}:
    get:
      summary: Get {{resource_name}} by ID
    put:
      summary: Update {{resource_name}}
    delete:
      summary: Delete {{resource_name}}
{{/if}}
```

### 2. Security Implementation

**Authentication & Authorization for {{auth_method}}:**

{{#switch auth_method}}
{{#case "jwt"}}
```javascript
// JWT Authentication Middleware
const jwt = require('jsonwebtoken');

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid token' });
    }
    req.user = user;
    next();
  });
};
```
{{/case}}
{{#case "oauth2"}}
```javascript
// OAuth 2.0 Integration
const passport = require('passport');
const OAuth2Strategy = require('passport-oauth2');

passport.use(new OAuth2Strategy({
  authorizationURL: process.env.OAUTH_AUTH_URL,
  tokenURL: process.env.OAUTH_TOKEN_URL,
  clientID: process.env.OAUTH_CLIENT_ID,
  clientSecret: process.env.OAUTH_CLIENT_SECRET,
  callbackURL: "/auth/callback"
}, (accessToken, refreshToken, profile, done) => {
  // Verify and create user session
  return done(null, profile);
}));
```
{{/case}}
{{/switch}}

**Input Validation & Sanitization:**
```javascript
const Joi = require('joi');

const {{resource_name}}Schema = Joi.object({
  name: Joi.string().min(1).max(255).required(),
  email: Joi.string().email().required(),
  // Add other fields as needed
});

const validateRequest = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.body);
  if (error) {
    return res.status(400).json({ 
      error: 'Validation failed',
      details: error.details 
    });
  }
  next();
};
```

### 3. Database Layer

**{{database}} Integration:**

{{#switch database}}
{{#case "postgresql"}}
```javascript
// PostgreSQL with connection pooling
const { Pool } = require('pg');

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT,
  ssl: process.env.NODE_ENV === 'production'
});

class {{resource_name}}Repository {
  async findAll(options = {}) {
    const { page = 1, limit = 20, filter } = options;
    const offset = (page - 1) * limit;
    
    let query = 'SELECT * FROM {{resource_name}}s';
    const params = [];
    
    if (filter) {
      query += ' WHERE name ILIKE $1';
      params.push(`%${filter}%`);
    }
    
    query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);
    
    const result = await pool.query(query, params);
    return result.rows;
  }
  
  async create(data) {
    const query = `
      INSERT INTO {{resource_name}}s (name, email, created_at)
      VALUES ($1, $2, NOW())
      RETURNING *
    `;
    const result = await pool.query(query, [data.name, data.email]);
    return result.rows[0];
  }
}
```
{{/case}}
{{#case "mongodb"}}
```javascript
// MongoDB with Mongoose
const mongoose = require('mongoose');

const {{resource_name}}Schema = new mongoose.Schema({
  name: { type: String, required: true, maxlength: 255 },
  email: { type: String, required: true, unique: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

{{resource_name}}Schema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

const {{resource_name}} = mongoose.model('{{resource_name}}', {{resource_name}}Schema);

class {{resource_name}}Repository {
  async findAll(options = {}) {
    const { page = 1, limit = 20, filter } = options;
    const skip = (page - 1) * limit;
    
    let query = {};
    if (filter) {
      query.name = { $regex: filter, $options: 'i' };
    }
    
    return await {{resource_name}}.find(query)
      .skip(skip)
      .limit(limit)
      .sort({ createdAt: -1 });
  }
  
  async create(data) {
    const instance = new {{resource_name}}(data);
    return await instance.save();
  }
}
```
{{/case}}
{{/switch}}

### 4. API Routes Implementation

**{{framework}} Routes:**

```javascript
{{#switch framework}}
{{#case "express"}}
const express = require('express');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');

const app = express();
const repository = new {{resource_name}}Repository();

// Security middleware
app.use(helmet());
app.use(express.json({ limit: '10mb' }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api', limiter);

{{#if (includes features "crud")}}
// GET /{{resource_name}}s
app.get('/api/{{resource_name}}s', authenticateToken, async (req, res) => {
  try {
    const { page, limit, filter } = req.query;
    const items = await repository.findAll({ 
      page: parseInt(page), 
      limit: parseInt(limit), 
      filter 
    });
    
    res.json({
      data: items,
      pagination: {
        page: parseInt(page) || 1,
        limit: parseInt(limit) || 20,
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST /{{resource_name}}s
app.post('/api/{{resource_name}}s', 
  authenticateToken, 
  validateRequest({{resource_name}}Schema),
  async (req, res) => {
    try {
      const item = await repository.create(req.body);
      res.status(201).json({ data: item });
    } catch (error) {
      if (error.code === '23505') { // Unique violation
        res.status(409).json({ error: 'Resource already exists' });
      } else {
        res.status(500).json({ error: 'Internal server error' });
      }
    }
  }
);
{{/if}}
{{/case}}
{{/switch}}
```

### 5. Testing Strategy

**Comprehensive API Testing:**

```javascript
// Jest + Supertest for API testing
const request = require('supertest');
const app = require('./app');

describe('{{resource_name}} API', () => {
  let authToken;
  
  beforeAll(async () => {
    // Setup test database and auth token
    authToken = 'test-token';
  });
  
  describe('GET /api/{{resource_name}}s', () => {
    test('should return paginated {{resource_name}}s', async () => {
      const response = await request(app)
        .get('/api/{{resource_name}}s')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);
      
      expect(response.body.data).toBeInstanceOf(Array);
      expect(response.body.pagination).toBeDefined();
    });
    
    test('should require authentication', async () => {
      await request(app)
        .get('/api/{{resource_name}}s')
        .expect(401);
    });
  });
});
```

## Deployment Checklist

- [ ] Environment variables configured
- [ ] Database migrations applied
- [ ] SSL/TLS certificates installed
- [ ] Rate limiting configured
- [ ] Monitoring and logging setup
- [ ] API documentation deployed
- [ ] Security headers configured
- [ ] Backup strategy implemented
- [ ] Performance testing completed
- [ ] Load balancing configured (if needed)

## Success Criteria

✅ **Functionality**: All CRUD operations work correctly
✅ **Security**: Authentication, validation, and rate limiting implemented
✅ **Performance**: Response times under 200ms for simple queries
✅ **Documentation**: OpenAPI spec with interactive docs
✅ **Testing**: 90%+ test coverage
✅ **Monitoring**: Metrics and logging in place
✅ **Scalability**: Can handle expected traffic load